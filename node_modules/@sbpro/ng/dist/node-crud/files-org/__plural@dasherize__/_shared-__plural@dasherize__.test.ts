import httpCodes from '@inip/http-codes';
import { mockGenerateError, requestMock } from '@mocks/fastify';
import { mockFind, mockFindByIds, mockFindOne } from '@mocks/typeorm';
import { Test<%= classify(name) %> } from '@testing/objects';

import { find<%= classify(name) %>, find<%= classify(plural) %>, find<%= classify(plural) %>Filter } from './<%= dasherize(plural) %>';

describe('<%= classify(plural) %> Shared', () => {
    describe('find<%= classify(name) %>', () => {
        beforeEach(() => {
            mockFindOne.mockReset();
        });
        it('should error if no id is passed', async () => {
            try {
                const returnValue = await find<%= classify(name) %>(requestMock, '');
            } catch (error) {
                expect(mockGenerateError).toHaveBeenLastCalledWith(
                    httpCodes.INTERNAL_SERVER_ERROR,
                    'NO_ID_FOR_FIND'
                );
            }
        });
        it('should return the found <%= camelize(name) %>', async () => {
            const test<%= classify(name) %> = new Test<%= classify(name) %>();
            mockFindOne.mockImplementation(() => test<%= classify(name) %>);
            const returnValue = await find<%= classify(name) %>(
                requestMock,
                '00000000-0000-0000-0000-000000000001'
            );
            expect(returnValue).toBe(test<%= classify(name) %>);
        });
        it('should error if the <%= camelize(name) %> does not exist', async () => {
            try {
                const returnValue = await find<%= classify(name) %>(
                    requestMock,
                    '00000000-0000-0000-0000-000000000001'
                );
            } catch (error) {
                expect(mockGenerateError).toHaveBeenLastCalledWith(
                    httpCodes.NOT_FOUND,
                    '<%= constantCase(name) %>_NOT_FOUND'
                );
            }
        });
        it('should catch errors when trying to find <%= camelize(name) %>', async () => {
            const thrownError = new Error('TEST_ERROR');
            mockFindOne.mockImplementation(() => {
                throw thrownError;
            });
            try {
                const returnValue = await find<%= classify(name) %>(
                    requestMock,
                    '00000000-0000-0000-0000-000000000001'
                );
            } catch (error) {
                expect(mockGenerateError).toHaveBeenLastCalledWith(
                    httpCodes.INTERNAL_SERVER_ERROR,
                    'ERROR_FINDING_<%= constantCase(name) %>',
                    thrownError
                );
            }
        });
    });
    describe('find<%= classify(plural) %>', () => {
        beforeEach(() => {
            mockFindByIds.mockReset();
        });
        it('should error if no ids are passed', async () => {
            try {
                const returnValue = await find<%= classify(plural) %>(requestMock, []);
            } catch (error) {
                expect(mockGenerateError).toHaveBeenLastCalledWith(
                    httpCodes.INTERNAL_SERVER_ERROR,
                    'NO_ID_FOR_FIND'
                );
            }
        });
        it('should return the found <%= camelize(plural) %>', async () => {
            const test<%= classify(name) %> = new Test<%= classify(name) %>();
            mockFindByIds.mockImplementation(() => [test<%= classify(name) %>, test<%= classify(name) %>]);
            const returnValue = await find<%= classify(plural) %>(requestMock, [
                '00000000-0000-0000-0000-000000000001',
                '00000000-0000-0000-0000-000000000002',
            ]);
            expect(returnValue.length).toBe(2);
        });
        it('should error if the <%= camelize(plural) %> do not exist', async () => {
            try {
                const returnValue = await find<%= classify(plural) %>(requestMock, [
                    '00000000-0000-0000-0000-000000000001',
                    '00000000-0000-0000-0000-000000000002',
                ]);
            } catch (error) {
                expect(mockGenerateError).toHaveBeenLastCalledWith(
                    httpCodes.NOT_FOUND,
                    '<%= constantCase(plural) %>_NOT_FOUND'
                );
            }
        });
        it('should catch errors when trying to find <%= camelize(plural) %>', async () => {
            const thrownError = new Error('TEST_ERROR');
            mockFindByIds.mockImplementation(() => {
                throw thrownError;
            });
            try {
                const returnValue = await find<%= classify(plural) %>(requestMock, [
                    '00000000-0000-0000-0000-000000000001',
                    '00000000-0000-0000-0000-000000000002',
                ]);
            } catch (error) {
                expect(mockGenerateError).toHaveBeenLastCalledWith(
                    httpCodes.INTERNAL_SERVER_ERROR,
                    'ERROR_FINDING_<%= constantCase(plural) %>',
                    thrownError
                );
            }
        });
    });
    describe('find<%= classify(plural) %>Filter', () => {
        beforeEach(() => {
            mockFind.mockReset();
        });
        it('should return the found <%= camelize(plural) %>', async () => {
            const test<%= classify(name) %> = new Test<%= classify(name) %>();
            mockFind.mockImplementation(() => [test<%= classify(name) %>, test<%= classify(name) %>]);
            const returnValue = await find<%= classify(plural) %>Filter(requestMock);
            expect(returnValue.length).toBe(2);
        });
        it('should error if the <%= camelize(plural) %> do not exist', async () => {
            try {
                const returnValue = await find<%= classify(plural) %>Filter(requestMock);
            } catch (error) {
                expect(mockGenerateError).toHaveBeenLastCalledWith(
                    httpCodes.NOT_FOUND,
                    '<%= constantCase(plural) %>_NOT_FOUND'
                );
            }
        });
        it('should catch errors when trying to find <%= camelize(plural) %>', async () => {
            const thrownError = new Error('TEST_ERROR');
            mockFind.mockImplementation(() => {
                throw thrownError;
            });
            try {
                const returnValue = await find<%= classify(plural) %>Filter(requestMock);
            } catch (error) {
                expect(mockGenerateError).toHaveBeenLastCalledWith(
                    httpCodes.INTERNAL_SERVER_ERROR,
                    'ERROR_FINDING_<%= constantCase(plural) %>',
                    thrownError
                );
            }
        });
    });
});
